version 1 .
embeddedType EntityRef.Cap .

Service = DaemonService .

DaemonService = <daemon @id any> .
DaemonProcess = <daemon @id any @config DaemonProcessSpec>.

DaemonProcessSpec = @simple CommandLine / @oneShot <one-shot @setup CommandLine> / @full FullDaemonProcess .
FullDaemonProcess = @process FullProcess & @readyOnStart ReadyOnStart & @restart RestartField & @protocol ProtocolField .
ReadyOnStart = @present { readyOnStart: bool } / @invalid { readyOnStart: any } / @absent {} .
RestartField = @present { restart: RestartPolicy } / @invalid { restart: any } / @absent {} .
ProtocolField = @present { protocol: Protocol } / @invalid { protocol: any } / @absent {} .

Process = @simple CommandLine / @full FullProcess .
FullProcess =
  & { argv: CommandLine }
  & @env ProcessEnv
  & @dir ProcessDir
  & @clearEnv ClearEnv
.
ProcessEnv = @present { env: { EnvVariable: EnvValue ...:... } } / @invalid { env: any } / @absent {} .
ProcessDir = @present { dir: string } / @invalid { dir: any } / @absent {} .
ClearEnv = @present { clearEnv: bool } / @invalid { clearEnv: any } / @absent {} .

CommandLine = @shell string / @full FullCommandLine .
FullCommandLine = [@program string, @args string ...] .

EnvVariable = @string string / @symbol symbol / @invalid any .
EnvValue = @set string / @remove #f / @invalid any .

RestartPolicy =
/ # Whether the process terminates normally or abnormally, restart it
  # without affecting any peer processes within the service.
  =always
/ # If the process terminates normally, leave everything alone; if it
  # terminates abnormally, restart it without affecting peers.
  @onError =on-error
/ # If the process terminates normally, leave everything alone; if it
  # terminates abnormally, restart the whole daemon (all processes
  # within the daemon).
  =all
/ # Treat both normal and abnormal termination as normal termination; that is, never restart,
  # and enter state "complete" even if the process fails.
  =never
.

Protocol =
/ # stdin is /dev/null, output and error are logged
  =none
/ # stdin and stdout are *binary* Syndicate-protocol channels
  @binarySyndicate =application/syndicate
/ # stdin and stdout are *text* Syndicate-protocol channels
  @textSyndicate =text/syndicate
.
